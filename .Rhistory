par(mar=c(4,4,1,1))
plot(log(pi_min),main='alpha=1',ylab='logP(w)',xlab='h')
points(log(pi_max),col='blue')
dev.off()
}
# rm(list = ls())
# graphics.off()
# dev.off()
if(F){
p_max=500
p_values = seq(10,p_max,by=10)
if(T){
a_chi=0.5
b_chi=0.1
var_spike=0.005
} else {
a_chi=2
b_chi=2
var_spike=0.05
}
var_sample = 0.01
# var_slab = 10*var_spike
pdf(paste0('~/Desktop/PDFs_v',var_sample,'.pdf'),width =4,height =3)
par(mar=c(4,4,1,1))
vec_v  <- seq(-3,3,by=0.01)
plot(vec_v,dnorm(vec_v,sd = sqrt(var_spike)),type='l',col='red',
ylab='pdf',xlab='x',main='',#main=paste0('var=',var_spike,'; a=',a_chi,'; b=',b_chi),
cex.main=0.7,cex.lab=0.7,cex.axis=0.7)
lines(vec_v,stevemisc::dst(vec_v,df=2*a_chi,mu=0,sigma = b_chi/a_chi),col='green')
# lines(vec_v,dnorm(vec_v,sd = sqrt(var_slab)),col='darkgreen')
lines(vec_v,dnorm(vec_v,sd = sqrt(var_sample)),col='purple')
legend('topleft',col=c('red','green','purple'),legend=c('spike','slab','sample'),pch=19)
dev.off()
Load_G <- rnorm(p_max,sd = sqrt(var_sample))
vec_G <- sapply(p_values,function(p) sum((Load_G^2)[1:p]))
logP_N <- -0.5*vec_G/var_spike - 0.5*p_values*log(2*pi*var_spike)
# logP_T <- -0.5*vec_G/var_slab - 0.5*p_values*log(2*pi*var_slab)
logP_T <- -(0.5*p_values+a_chi)*log(1+0.5*vec_G/b_chi) +
lgamma(0.5*p_values+a_chi) - lgamma(a_chi) - 0.5*p_values*log(2*pi*b_chi)
pdf(paste0('~/Desktop/logPz_v',var_sample,'.pdf'),width =4,height =3)
par(mar=c(4,4,1,1))
y_min=min(logP_N,logP_T)
y_max=max(logP_N,logP_T)
plot(p_values,logP_N,type='l',col='red',ylim = c(y_min,y_max),
main='',xlab = 'p',ylab='logP')
lines(p_values,logP_T,col='green')
legend('right',col=c('red','green'),legend=c('spike','slab'),pch=19)
dev.off()
logP_N_0 = logP_N
logP_T_0 = logP_T
# logP_N=logP_N/((p_values)^(1))
logP_N=logP_N/((p_values)^(1/2))
# logP_T=logP_T/((p_values)^(1))
logP_T=logP_T/((p_values)^(1/2))
pdf(paste0('~/Desktop/logPz_rescaled_v',var_sample,'.pdf'),width =4,height =3)
par(mar=c(4,4,1,1))
y_min=min(logP_N,logP_T)
y_max=max(logP_N,logP_T)
plot(p_values,logP_N,type='l',col='red',ylim = c(y_min,y_max),
main='',xlab = 'p',ylab='logP')
lines(p_values,logP_T,col='green')
legend('right',col=c('red','green'),legend=c('spike','slab'),pch=19)
dev.off()
# plot(p_values,logP_N_0/(p_values), col='darkred')
# plot(p_values,logP_T_0/(p_values), col='darkgreen')
}
if(F){
t0=-1; t1=-5e-4 # t1=-1e-4
t0_adapt=200
tMax = 20000
t_values = seq(t0_adapt,tMax,by=10)
plot(t_values,exp(t0 + t1*t_values),type='l')
}
ris1
ris2
plot(ris1,ris2)
rm(list = ls())
update_cusp_mod <- function(K,logP_Spikes,logP_Slabs,pi_m,seed=123){
set.seed(seed)
# un-normalized (log)-probability matrices
lonP_N <- matrix(logP_Spikes,K,K)
logP_T <- matrix(logP_Slabs,K,K)
# un-normalized (log)-probability matrix
lonP_D <- lonP_N
lonP_D[upper.tri(lonP_D,diag=F)] <- logP_T[upper.tri(lonP_D,diag=F)]
lonP_D <- lonP_D + t(matrix(log(pi_m),K,K))
# normalized probability matrix
max_pD <- matrix(apply(lonP_D, 1, max),K,K)
pr_D   <- exp(lonP_D - max_pD)
pr_Tot <- apply(pr_D, 1, sum)
pr_D   <- pr_D/pr_Tot
# sampling
#| Remarks:
#|    in Hmisc::rMultinom(probs,nsample), the h-th row of `probs` gives the
#|    probabilities for the l classes among which the h-th variable is sampled
delta_m  <- as.vector(Hmisc::rMultinom(pr_D,1))
return(delta_m)
}
M=3
K=15
p=1000
a_chi=0.5
b_chi=0.1
var_spike=0.005
var_sample = 0.01
w = 1/1:K
w = w / sum(w)
pow_m = p^(1/2)
Load_G <- matrix(rnorm(K*p,sd = sqrt(var_sample)),ncol=K)
vec_G  <- colSums(Load_G[,1:K,drop=F]^2)
logP_N <- -0.5*vec_G/var_spike - 0.5*p*log(2*pi*var_spike)
logP_T <- -(0.5*p+a_chi)*log(1+0.5*vec_G/b_chi) +
lgamma(0.5*p+a_chi) - lgamma(a_chi) - 0.5*p*log(2*pi*b_chi)
ris1 = update_cusp_mod(K,logP_N,logP_T,w^pow_m)
logP_spike <- logP_N / (pow_m)
logP_slab <- logP_T / (pow_m)
ris2 <- update_cusp_mod(K,logP_spike,logP_slab,w)
ris1
ris2
rm(list = ls())
update_cusp_mod <- function(K,logP_Spikes,logP_Slabs,pi_m,pow_m,seed=123){
set.seed(seed)
# un-normalized (log)-probability matrices
lonP_N <- matrix(logP_Spikes,K,K)
logP_T <- matrix(logP_Slabs,K,K)
# un-normalized (log)-probability matrix
lonP_D <- lonP_N
lonP_D[upper.tri(lonP_D,diag=F)] <- logP_T[upper.tri(lonP_D,diag=F)]
lonP_D <- lonP_D + t(matrix(pow_m*log(pi_m),K,K))
# normalized probability matrix
max_pD <- matrix(apply(lonP_D, 1, max),K,K)
pr_D   <- exp(lonP_D - max_pD)
pr_Tot <- apply(pr_D, 1, sum)
pr_D   <- pr_D/pr_Tot
# sampling
#| Remarks:
#|    in Hmisc::rMultinom(probs,nsample), the h-th row of `probs` gives the
#|    probabilities for the l classes among which the h-th variable is sampled
delta_m  <- as.vector(Hmisc::rMultinom(pr_D,1))
return(delta_m)
}
M=3
K=15
p=1000
a_chi=0.5
b_chi=0.1
var_spike=0.005
var_sample = 0.01
w = 1/1:K
w = w / sum(w)
pow_m = p^(1/2)
Load_G <- matrix(rnorm(K*p,sd = sqrt(var_sample)),ncol=K)
vec_G  <- colSums(Load_G[,1:K,drop=F]^2)
logP_N <- -0.5*vec_G/var_spike - 0.5*p*log(2*pi*var_spike)
logP_T <- -(0.5*p+a_chi)*log(1+0.5*vec_G/b_chi) +
lgamma(0.5*p+a_chi) - lgamma(a_chi) - 0.5*p*log(2*pi*b_chi)
ris1 = update_cusp_mod(K,logP_N,logP_T,w,pow_m)
logP_spike <- logP_N / (pow_m)
logP_slab <- logP_T / (pow_m)
ris2 <- update_cusp_mod(K,logP_spike,logP_slab,w,1)
ris1
ris2
rm(list = ls())
update_cusp_mod <- function(K,logP_Spikes,logP_Slabs,pi_m,pow_m,seed=123){
set.seed(seed)
# un-normalized (log)-probability matrices
lonP_N <- matrix(logP_Spikes,K,K)
logP_T <- matrix(logP_Slabs,K,K)
# un-normalized (log)-probability matrix
lonP_D <- lonP_N
lonP_D[upper.tri(lonP_D,diag=F)] <- logP_T[upper.tri(lonP_D,diag=F)]
lonP_D <- lonP_D + t(matrix(pow_m*log(pi_m),K,K))
# normalized probability matrix
max_pD <- matrix(apply(lonP_D, 1, max),K,K)
pr_D   <- exp((lonP_D - max_pD)/pow_m)
pr_Tot <- apply(pr_D, 1, sum)
pr_D   <- pr_D/pr_Tot
# sampling
#| Remarks:
#|    in Hmisc::rMultinom(probs,nsample), the h-th row of `probs` gives the
#|    probabilities for the l classes among which the h-th variable is sampled
delta_m  <- as.vector(Hmisc::rMultinom(pr_D,1))
return(delta_m)
}
M=3
K=15
p=1000
a_chi=0.5
b_chi=0.1
var_spike=0.005
var_sample = 0.01
w = 1/1:K
w = w / sum(w)
pow_m = p^(1/2)
Load_G <- matrix(rnorm(K*p,sd = sqrt(var_sample)),ncol=K)
vec_G  <- colSums(Load_G[,1:K,drop=F]^2)
logP_N <- -0.5*vec_G/var_spike - 0.5*p*log(2*pi*var_spike)
logP_T <- -(0.5*p+a_chi)*log(1+0.5*vec_G/b_chi) +
lgamma(0.5*p+a_chi) - lgamma(a_chi) - 0.5*p*log(2*pi*b_chi)
ris1 = update_cusp_mod(K,logP_N,logP_T,w,pow_m)
logP_spike <- logP_N / (pow_m)
logP_slab <- logP_T / (pow_m)
ris2 <- update_cusp_mod(K,logP_spike,logP_slab,w,1)
ris1
ris2
rm(list = ls())
update_cusp_mod <- function(K,logP_Spikes,logP_Slabs,pi_m,pow_m,seed=123){
set.seed(seed)
# un-normalized (log)-probability matrices
lonP_N <- matrix(logP_Spikes,K,K)
logP_T <- matrix(logP_Slabs,K,K)
# un-normalized (log)-probability matrix
lonP_D <- lonP_N
lonP_D[upper.tri(lonP_D,diag=F)] <- logP_T[upper.tri(lonP_D,diag=F)]
lonP_D <- lonP_D + t(matrix(pow_m*log(pi_m),K,K))
# normalized probability matrix
max_pD <- matrix(apply(lonP_D, 1, max),K,K)
# pr_D   <- exp((lonP_D - max_pD)/pow_m)
pr_D   <- exp(lonP_D - max_pD)
pr_Tot <- apply(pr_D, 1, sum)
pr_D   <- pr_D/pr_Tot
# sampling
#| Remarks:
#|    in Hmisc::rMultinom(probs,nsample), the h-th row of `probs` gives the
#|    probabilities for the l classes among which the h-th variable is sampled
delta_m  <- as.vector(Hmisc::rMultinom(pr_D,1))
return(delta_m)
}
M=3
K=15
p=1000
a_chi=0.5
b_chi=0.1
var_spike=0.005
var_sample = 0.01
w = 1/1:K
w = w / sum(w)
pow_m = p^(1/2)
Load_G <- matrix(rnorm(K*p,sd = sqrt(var_sample)),ncol=K)
vec_G  <- colSums(Load_G[,1:K,drop=F]^2)
logP_N <- -0.5*vec_G/var_spike - 0.5*p*log(2*pi*var_spike)
logP_T <- -(0.5*p+a_chi)*log(1+0.5*vec_G/b_chi) +
lgamma(0.5*p+a_chi) - lgamma(a_chi) - 0.5*p*log(2*pi*b_chi)
ris1 = update_cusp_mod(K,logP_N,logP_T,w,pow_m)
logP_spike <- logP_N / (pow_m)
logP_slab <- logP_T / (pow_m)
ris2 <- update_cusp_mod(K,logP_spike,logP_slab,w,1)
ris1
ris2
ris1>1:K
ris2>1:K
plot(ris1,ris2)
plot(ris1,ris2);abline(a=0,b=1)
hist(ris1)
hist(ris2)
w
rm(list = ls())
run_cluster = F
if(run_cluster){
path <- '/hpc/group/dunsonlab/na224/multiomics/' # cluster simulations
} else{
path <- '~/Documents/GitHub/jafar/' # local simulations
}
setwd(path)
# Loading Packages -------------------------------------------------------------
# library(...)
# Files and Folder -------------------------------------------------------------
## Select model and data ----
run_simulations = F
run_supervised = F
predict_views = F
whichCUSP = 'i-cusp' # 'jfr' #
if(!whichCUSP%in%c('d-cusp','i-cusp','i-cusp-naive', 'jfr')){
stop("whichCUSP must be on of 'd-cusp', 'i-cusp', 'i-cusp-naive' or 'jfr'")
}
## Source code ----
source_dir = "new_source"
if(!dir.exists(source_dir)){stop("Source folder not found", call.=FALSE)}
source_files = c("jafar_gibbs.R", "jfr_gibbs.R", "jafar_initialization.R",
"jafar_updates.R", "jafar_predictions.R",
"Sec3_simulations_preproc.R")
for(s_file in source_files){
if(!file.exists(file.path(source_dir, s_file))){stop(paste0("Source file '",s_file,"' not found"))}
source(file.path(source_dir, s_file))
}
# source_file_py = "jafar_get_array_indicators.py"
# if(!file.exists(file.path(source_dir, source_file_py))){stop("python update file not found")}
# reticulate::source_python(file.path(source_dir, source_file_py))
updates_source_rcpp = "jafar_updates.cpp"
if(!file.exists(file.path(source_dir, updates_source_rcpp))){stop("cpp update file not found")}
Rcpp::sourceCpp(file.path(source_dir, updates_source_rcpp))
## Output Folder ----
out_dir = 'ris/'
if(!dir.exists(out_dir)){dir.create(out_dir)}
## Data import  ----
print(' | Loading Data ')
if(run_simulations){
out_dir <- paste0(out_dir,'sim_sec3')
if(!dir.exists(out_dir)){dir.create(out_dir)}
if(run_cluster){
if (length(commandArgs(trailingOnly = TRUE)) != 2) {
stop("Usage: your_script.R <n> <s>")
}
nn <- as.integer(commandArgs(trailingOnly = TRUE)[1])
ss <- as.integer(commandArgs(trailingOnly = TRUE)[2])
} else {
nn <- 50 # 100 # 200 #
ss <- 10 # 5 #
}
data_file <- paste0('Simulated_data_n200_s',ss)
} else {
if(run_cluster){
if (length(commandArgs(trailingOnly = TRUE)) != 1) {
stop("Usage: your_script.R <s>")
}
ss <- as.integer(commandArgs(trailingOnly = TRUE)[1])
} else {
ss <- 1
}
data_file <- 'StelzerEGA_cv-'
}
if(run_simulations){
data_dir = "data/Sec3_Simulations"
data_path = file.path(data_dir, paste0(data_file,'.rds'))
} else {
data_dir = "data/Sec4_StelzerEGA"
data_path = file.path(data_dir, paste0(data_file,ss,'_copula.rds'))
}
if(!dir.exists(data_dir)){stop("Input data folder not found", call.=FALSE)}
if(!file.exists(data_path)){stop("Data file not found")}
data_path <- "~/Desktop/StelzerEGA_Data_cleaning/StelzerEGA_data_raw.rds" # TODO: remove
Data <- readRDS(data_path)
if(run_simulations){
Data <- data_scale_subset(Data,nn)
data_file <- paste0('Sec3_Simulated_data_n',nn,'_s',ss)
} else {
data_file <- paste0(data_file,'s',ss)
}
y_run=NULL
if(run_supervised){
y_run = Data$yTrain
}
binary_y=as.logical(min(Data$yTrain%%1==0))
# MCMC Parameters --------------------------------------------------------------
# K0 = 30 # 40 #
# K0_m = c(20,25,20) # rep(35,Data$M) #
K0 = 10 # 40 #
K0_m = c(10,10,10) # rep(35,Data$M) #
if(whichCUSP=='jfr'){K0=K0*2}
nMCMC = 20000 # 20000 #
nBurnIn = 15000 # 15000 #
nThin = 10 # 1 #
hp_mcmc <- list(
t0=-1, t1=-1e-4, t0_adapt=200, seed=123,
a_sig=3, b_sig=1, prec0=1/4,
a_theta=0.5, b_theta=0.1, var_spike_y=0.005,
a_m=3, b_m=1,
a_chi=0.5, b_chi=0.1, var_spike=0.005,
# a_chi=2,  b_chi=2, var_spike=0.05,
# alpha=10, alpha_loc=10,
alpha=5, alpha_loc=5,
# alpha=1, alpha_loc=1,
a_xi=3, b_xi=2
)
if(whichCUSP %in% c('i-cusp','i-cusp-naive')){
hp_mcmc$alpha = hp_mcmc$alpha / sqrt(Data$M)
# hp_mcmc$alpha = hp_mcmc$alpha
} else if(whichCUSP=='jfr'){
hp_mcmc$alpha = sum(hp_mcmc$alpha+Data$M*hp_mcmc$alpha_loc) / sqrt(Data$M)
}
# Gibbs Sampler ----------------------------------------------------------------
print(' | Running MCMC and computing predicitions ')
print(paste0('Which CUSPs: ',whichCUSP))
init_time <- proc.time()
if(whichCUSP %in% c('d-cusp','i-cusp','i-cusp-naive')){
ris_MCMC <- gibbs_jafar(Data$X_m, y_run, yBinary=binary_y, K0=K0, K0_m=K0_m,
which_prior=whichCUSP,hyperparams = hp_mcmc,
nMCMC=nMCMC, nBurnIn=nBurnIn, nThin=nThin,
get_latent_vars=T, rescale_pred=T,pow_rescale=1)
} else {
ris_MCMC <- gibbs_jfr(Data$X_m, y_run, yBinary=binary_y, K0=K0,
hyperparams = hp_mcmc,
nMCMC=nMCMC, nBurnIn=nBurnIn, nThin=nThin,
get_latent_vars=T, rescale_pred=T,pow_rescale=1)
}
rm(list = ls())
run_cluster = F
if(run_cluster){
path <- '/hpc/group/dunsonlab/na224/multiomics/' # cluster simulations
} else{
path <- '~/Documents/GitHub/jafar/' # local simulations
}
setwd(path)
# Loading Packages -------------------------------------------------------------
# library(...)
# Files and Folder -------------------------------------------------------------
## Select model and data ----
run_simulations = F
run_supervised = F
predict_views = F
whichCUSP = 'i-cusp' # 'jfr' #
if(!whichCUSP%in%c('d-cusp','i-cusp','i-cusp-naive', 'jfr')){
stop("whichCUSP must be on of 'd-cusp', 'i-cusp', 'i-cusp-naive' or 'jfr'")
}
## Source code ----
source_dir = "new_source"
if(!dir.exists(source_dir)){stop("Source folder not found", call.=FALSE)}
source_files = c("jafar_gibbs.R", "jfr_gibbs.R", "jafar_initialization.R",
"jafar_updates.R", "jafar_predictions.R",
"Sec3_simulations_preproc.R")
for(s_file in source_files){
if(!file.exists(file.path(source_dir, s_file))){stop(paste0("Source file '",s_file,"' not found"))}
source(file.path(source_dir, s_file))
}
# source_file_py = "jafar_get_array_indicators.py"
# if(!file.exists(file.path(source_dir, source_file_py))){stop("python update file not found")}
# reticulate::source_python(file.path(source_dir, source_file_py))
updates_source_rcpp = "jafar_updates.cpp"
if(!file.exists(file.path(source_dir, updates_source_rcpp))){stop("cpp update file not found")}
Rcpp::sourceCpp(file.path(source_dir, updates_source_rcpp))
## Output Folder ----
out_dir = 'ris/'
if(!dir.exists(out_dir)){dir.create(out_dir)}
## Data import  ----
print(' | Loading Data ')
if(run_simulations){
out_dir <- paste0(out_dir,'sim_sec3')
if(!dir.exists(out_dir)){dir.create(out_dir)}
if(run_cluster){
if (length(commandArgs(trailingOnly = TRUE)) != 2) {
stop("Usage: your_script.R <n> <s>")
}
nn <- as.integer(commandArgs(trailingOnly = TRUE)[1])
ss <- as.integer(commandArgs(trailingOnly = TRUE)[2])
} else {
nn <- 50 # 100 # 200 #
ss <- 10 # 5 #
}
data_file <- paste0('Simulated_data_n200_s',ss)
} else {
if(run_cluster){
if (length(commandArgs(trailingOnly = TRUE)) != 1) {
stop("Usage: your_script.R <s>")
}
ss <- as.integer(commandArgs(trailingOnly = TRUE)[1])
} else {
ss <- 1
}
data_file <- 'StelzerEGA_cv-'
}
if(run_simulations){
data_dir = "data/Sec3_Simulations"
data_path = file.path(data_dir, paste0(data_file,'.rds'))
} else {
data_dir = "data/Sec4_StelzerEGA"
data_path = file.path(data_dir, paste0(data_file,ss,'_copula.rds'))
}
if(!dir.exists(data_dir)){stop("Input data folder not found", call.=FALSE)}
if(!file.exists(data_path)){stop("Data file not found")}
data_path <- "~/Desktop/StelzerEGA_Data_cleaning/StelzerEGA_data_raw.rds" # TODO: remove
Data <- readRDS(data_path)
if(run_simulations){
Data <- data_scale_subset(Data,nn)
data_file <- paste0('Sec3_Simulated_data_n',nn,'_s',ss)
} else {
data_file <- paste0(data_file,'s',ss)
}
y_run=NULL
if(run_supervised){
y_run = Data$yTrain
}
binary_y=as.logical(min(Data$yTrain%%1==0))
# MCMC Parameters --------------------------------------------------------------
K0 = 30 # 40 #
K0_m = c(20,25,20) # rep(35,Data$M) #
if(whichCUSP=='jfr'){K0=K0*2}
nMCMC = 20000 # 20000 #
nBurnIn = 15000 # 15000 #
nThin = 10 # 1 #
hp_mcmc <- list(
t0=-1, t1=-1e-4, t0_adapt=200, seed=123,
a_sig=3, b_sig=1, prec0=1/4,
a_theta=0.5, b_theta=0.1, var_spike_y=0.005,
a_m=3, b_m=1,
a_chi=0.5, b_chi=0.1, var_spike=0.005,
# a_chi=2,  b_chi=2, var_spike=0.05,
# alpha=10, alpha_loc=10,
alpha=5, alpha_loc=5,
# alpha=1, alpha_loc=1,
a_xi=3, b_xi=2
)
if(whichCUSP %in% c('i-cusp','i-cusp-naive')){
hp_mcmc$alpha = hp_mcmc$alpha / sqrt(Data$M)
# hp_mcmc$alpha = hp_mcmc$alpha
} else if(whichCUSP=='jfr'){
hp_mcmc$alpha = sum(hp_mcmc$alpha+Data$M*hp_mcmc$alpha_loc) / sqrt(Data$M)
}
# Gibbs Sampler ----------------------------------------------------------------
print(' | Running MCMC and computing predicitions ')
print(paste0('Which CUSPs: ',whichCUSP))
init_time <- proc.time()
if(whichCUSP %in% c('d-cusp','i-cusp','i-cusp-naive')){
ris_MCMC <- gibbs_jafar(Data$X_m, y_run, yBinary=binary_y, K0=K0, K0_m=K0_m,
which_prior=whichCUSP,hyperparams = hp_mcmc,
nMCMC=nMCMC, nBurnIn=nBurnIn, nThin=nThin,
get_latent_vars=T, rescale_pred=T,pow_rescale=1)
} else {
ris_MCMC <- gibbs_jfr(Data$X_m, y_run, yBinary=binary_y, K0=K0,
hyperparams = hp_mcmc,
nMCMC=nMCMC, nBurnIn=nBurnIn, nThin=nThin,
get_latent_vars=T, rescale_pred=T,pow_rescale=1)
}
